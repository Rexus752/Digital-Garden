---
draft: true
---
![](Passaggi.png)

# 1 - Preprocessore
- Riceve in input un programma scritto in C (in realtà, non è un obbligo)
- Restituisce in output un altro file di testo dove ogni direttiva presente è stata intepretata e rimpiazzata/espansa con il testo corrispondente
- Direttive
	- `#define`
	- `#include`
	- `#if`, `#ifdef`, `#ifndef`

## Direttiva `#include`

### `#include <nomefile.h>`

```c
#include <nomefile.h>
```

Inserisce nel punto in cui si trova la direttiva il contenuto del file `nomefile.h`

La ricerca avviene solo nelle cartelle di sistema (es: `/usr/include`), e non nella directory corrente

### `#include "nome file.h"`

```c
#include "nome file.h"
```

La ricerca del fine avviene prima nella directory corrente e poi nelle cartelle di sistema

%%
```bash
gcc –E nome file.c
```

(per vedere l’output del preprocessore)

```bash
gcc –I /home/schi/mylibs
```
(per aggiungere una cartella di ricerca) %\%cioè?%\%

```bash
ldd <eseguibile>
```
Permette di conoscere le librerie utilizzate da un eseguibile

```bash
cp /usr/lib/aarch64-linux-gnu/libc.a .
ar x libc.a
ls –l | grep printf
```
Contenuto della libreria `libc` (dipende dall’architettura)
%%

### `glibc`

La libreria standard (glibc) offre diverse librerie che useremo nel
corso di questo corso
- stdio.h
- string.h
- math.h
- errno.h
- limits.h
- stdlib.h
- ctype.h
- …

## Direttiva `#define`

Permette di definire un nome simbolico per la definizione di una costante o una macro

Per convenzione, i nomi simbolici si definiscono in SCREAMING_SNAKE_CASE%%link alla convenzione%%

`#define` è usata anche per definire macro parametriche

### Esempio

```c
#define VEC_LEN 80

int v[VEC_LEN], i;

for (i = 0; i < VEC_LEN; i++) {
	/* something */
}
```

### Esempio macro parametrica

```c
#define SQUARE(x) x * x

a = SQUARE(2) + SQUARE(3);
```

diventa in pre-processing

```c
a = 2 * 2 + 3 * 3;
```

cioè è stata sostituita la macro con l'istruzione con i parametri `2` e `3`.

### Attenzione!

```c
#define SUM(x, y) x + y

a = SUM(1, 2) * SUM(3, 4);
```

diventa

```c
a = 1 + 2 * 3 + 4;
```

che, secondo le regole di precedenza degli operatori, corrisponde all'istruzione

```c
a = 1 + (2 * 3) + 4;
```

e ha come risultato `11`.

Ma questo non è ciò che volevamo fare noi, quindi modifichiamo la macro:

```c
#define SUM(x, y) (x + y)

a = SUM(1, 2) * SUM(3, 4);
```

diventa

```c
a = (1 + 2) * (3 + 4);
```

che ha come risultato `21`, cioè quello che volevamo noi.

### Multilinea

Le direttive solitamente sono composte da una sola linea. È possibile definirne anche con più linee:
```c
#define EXCHANGE(type, a, b) {\
		type aux ;\
		aux = a;\
		a = b;\
		b = aux;\
	\}
```

### Parametri "letterali"%%cambiare nome heading%%

I parametri di una macro, se indicati con #, vengono sostituiti con la stringa del nome stesso e non con il valore:

```c
#define PRINT_INTV(v) printf("%s = %d\n", #v, v);

int var1 = 10;
PRINT_INTV(var1);
```

sarà trasformato in

```c
printf("%s = %d\n", "var1", 10);
```

e stamperà in output

```
var1 = 10
```

### Macro a runtime

Una macro può essere anche definita a runtime quando si invoca il compilatore gcc:

```bash
gcc –D PI=3.14
```

(equivalente a `#define PI 3.14` nel file)

### Costante senza valore

E’ possibile definire una costante senza valore (utile per le direttive condizionali):

```c
#define DEBUG
```

### Macro predefinite

- **`__LINE__`**: a decimal constant representing the current line number.
- **`__FILE__`**: a string representing the current name of the source code file.
- **`__DATE__`**: a string representing the current date when compiling began for the current source file. It is in the format `MM DD YYYY`, the same as what is generated by the `asctime` function%%link%%.
- **`__TIME__`**: a string literal representing the current time when compiling began for the current source file. It is in the format `hh:mm:ss`, the same as what is generated by the `asctime` function%%link%%.

### Inclusioni condizionali con `#if`, `#ifdef` e `#ifndef`

È possibile includere porzioni di codice in base:
- Alla valutazione di una espressione che contiene costanti definite prima
	```c
	#if <condizione>
	/* <codice incluso se vero> */
	#else
	/* <codice incluso se falso> */
	#endif
	```
- Alla definizione (o meno) di una macro. Usato anche per evitare inclusioni cicliche (vedere le slides successive):
	```c
	#ifdef PLUTO
	/* codice inserito se PIPPO è definito */
	#endif
	```
	e
	```c
	#ifndef PLUTO
	/* codice inserito se PIPPO non è definito */
	#endif
	```

#### Esempio

```c
#include <assert.h>

...

list add_node(list list_ptr, int value) {

	#ifdef DEBUG
		assert(list_ptr != NULL);
	#endif
	
	node* new_elem = malloc(sizeof(node));
	
	...
	
	return list_ptr;
}
```

compilandolo con `gcc –D DEBUG=1` possiamo attivare funzioni di debug.

# 2 - Compilazione

Il compilatore si occupa di tradurre l’output del preprocessore in un file di testo contenente una sequenza di istruzioni assembly. Per fermare l’esecuzione dopo la compilazione:

```bash
gcc –S <nome file.c>
```

## Opzioni di compilazione

Ci sono moltissime opzioni:
- **`-g`**: aggiunge le info di debug (usato per gdb)
- **`-O2 -Os –O0`**: per i vari livelli di ottimizzazione
- **`-std=c89`**: seleziona lo standard ANSI C (1989)
	- Per questo standard, le variabili vanno dichiarate solo all’inizio di un blocco (ad esempio, `for (int i=0; i<10; i++)`, non rispetta lo standard perché non dichiara la variabile `i` all'inizio del blocco).
	- I commenti inline non sono ammessi (solo `/* */`).
- **`-Wall`**: visualizza tutti i warnings
- **`-pedantic`**: non compila programmi non conformi con lo standard ANSI C
- **`-m32 –marm`**: per compilare su altre architetture
- **`-lm`**: per utilizzare le librerie matematiche
- **`-S`**:

# Assemblatore

Prende in input il file testo del compilatore, produce il file binario oggetto. Per fermare la compilazione dopo l’assemblatore:

```bash
gcc –c <nome file.c>
```

Per vedere il contenuto del file oggetto:

```bash
hexdump –C <nome file.o>
```

# Linking

Prende in input uno o più file oggetto. Un solo file in input deve avere definita la funzione `main()`. Restituisce un file eseguibile chiamato `a.out` su Linux e `a.exe` su Windows %%e su macOS?%%

Con l’opzione –o il nome può essere modificato

```bash
gcc <nome file1>.o <nome file2>.o <eventuali altri file> –o <nome eseguibile>
```

# Fonti

- Slide del Prof. Schifanella Claudio del corso di Laboratorio di Sistemi Operativi (canale B, turno T4), Corso di Laurea in Informatica presso l'Università di Torino, A.A. 2024-25:
	- [Slide: ripasso su direttive, programmazione modulare, utility make](https://informatica.i-learn.unito.it/mod/resource/view.php?id=253526)